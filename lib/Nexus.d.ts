import * as types from './types';
import * as graphQL from './typesGraphQL';
import { IGraphQLError, LogFunc } from './types';
import { RatingOptions } from '.';
declare class Nexus {
    private mBaseData;
    private mBaseURL;
    private mUserServiceBaseURL;
    private mGraphBaseURL;
    private mQuota;
    private mValidationResult;
    private mRateLimit;
    private mLogCB;
    private mOAuthCredentials;
    private mOAuthConfig;
    private mJWTRefreshCallback;
    private mJwtRefreshTries;
    constructor(appName: string, appVersion: string, defaultGame: string, timeout?: number);
    static create(apiKey: string, appName: string, appVersion: string, defaultGame: string, timeout?: number): Promise<Nexus>;
    setLogger(logCB: LogFunc): void;
    static createWithOAuth(credentials: types.IOAuthCredentials, config: types.IOAuthConfig, appName: string, appVersion: string, defaultGame: string, timeout?: number, onJWTRefresh?: (credentials: types.IOAuthCredentials) => void): Promise<Nexus>;
    setGame(gameId: string): void;
    revalidate(): Promise<types.IValidateKeyResponse>;
    getValidationResult(): types.IValidateKeyResponse;
    setOAuthCredentials(credentials: types.IOAuthCredentials, config: types.IOAuthConfig, onJWTRefresh: (credentials: types.IOAuthCredentials) => void): Promise<types.IValidateKeyResponse>;
    setKey(apiKey: string): Promise<types.IValidateKeyResponse>;
    getRateLimits(): {
        daily: number;
        hourly: number;
    };
    validateKey(key?: string): Promise<types.IValidateKeyResponse>;
    getUserInfo(): Promise<types.IUserInfo>;
    getTrackedMods(): Promise<types.ITrackedMod[]>;
    trackMod(modId: string, gameId?: string): Promise<types.ITrackResponse>;
    untrackMod(modId: string, gameId?: string): Promise<types.ITrackResponse>;
    getGames(): Promise<types.IGameListEntry[]>;
    getLatestAdded(gameId?: string): Promise<types.IModInfo[]>;
    getLatestUpdated(gameId?: string): Promise<types.IModInfo[]>;
    getTrending(gameId?: string): Promise<types.IModInfo[]>;
    getEndorsements(): Promise<types.IEndorsement[]>;
    getColourschemes(): Promise<types.IColourScheme[]>;
    getColorschemes(): Promise<types.IColourScheme[]>;
    getGameInfo(gameId?: string): Promise<types.IGameInfo>;
    getRecentlyUpdatedMods(period: types.UpdatePeriod, gameId?: string): Promise<types.IUpdateEntry[]>;
    endorseMod(modId: number, modVersion: string, endorseStatus: 'endorse' | 'abstain', gameId?: string): Promise<types.IEndorseResponse>;
    getModInfo(modId: number, gameId?: string): Promise<types.IModInfo>;
    getChangelogs(modId: number, gameId?: string): Promise<types.IChangelogs>;
    getModFiles(modId: number, gameId?: string): Promise<types.IModFiles>;
    getFileInfo(modId: number, fileId: number, gameId?: string): Promise<types.IFileInfo>;
    getDownloadURLs(modId: number, fileId: number, key?: string, expires?: number, gameId?: string): Promise<types.IDownloadURL[]>;
    getFileByMD5(hash: string, gameId?: string): Promise<types.IMD5Result[]>;
    userById(query: graphQL.IUserQuery, userId: number): Promise<types.IGraphUser>;
    modsByUid(query: graphQL.IModQuery, uids: string[]): Promise<Partial<types.IMod>[]>;
    modFilesByUid(query: graphQL.IModFileQuery, uids: string[]): Promise<Partial<types.IModFile>[]>;
    fileHashes(query: graphQL.IFileHashQuery, md5Hashes: string[]): Promise<{
        data: Partial<types.IFileHash>[];
        errors: IGraphQLError[];
    }>;
    getCollectionDownloadLink(downloadLink: string): Promise<types.IDownloadURL[]>;
    createCollection(data: types.ICollectionPayload, assetFileUUID: string, retQuery?: graphQL.ICreateCollectionQuery): Promise<types.ICreateCollectionResult>;
    updateCollection(data: types.ICollectionPayload, assetFileUUID: string, collectionId: number, retQuery?: graphQL.ICreateCollectionQuery): Promise<types.ICreateCollectionResult>;
    createOrUpdateRevision(data: types.ICollectionPayload, assetFileUUID: string, collectionId: number, retQuery?: graphQL.ICreateCollectionQuery): Promise<types.ICreateCollectionResult>;
    editCollection(collectionId: number, name: string, summary?: string, description?: string, category?: number): Promise<boolean>;
    publishRevision(revisionId: number): Promise<boolean>;
    attachCollectionsToCategory(categoryId: number, collectionIds: number[]): Promise<boolean>;
    getCollectionGraph(query: graphQL.ICollectionQuery, slug: string, ignoreAdultBlock?: boolean): Promise<Partial<types.ICollection>>;
    getCollectionListGraph(query: graphQL.ICollectionQuery, gameId?: string, count?: number, offset?: number): Promise<Partial<types.ICollection>[]>;
    getMyCollections(query: graphQL.ICollectionQuery, gameId?: string, count?: number, offset?: number): Promise<Partial<types.ICollection>[]>;
    getCollectionRevisionGraph(query: graphQL.IRevisionQuery, collectionSlug: string, revisionNumber: number, ignoreAdultBlock?: boolean): Promise<Partial<types.IRevision>>;
    getRevisionUploadUrl(): Promise<types.IPreSignedUrl>;
    endorseCollection(collectionId: number, endorseStatus: 'abstain' | 'endorse', gameId?: string): Promise<{
        success: boolean;
    }>;
    rateRevision(revisionId: number, rating: RatingOptions): Promise<{
        success: boolean;
        averageRating: types.IRating;
    }>;
    getCollectionVideo(collectionId: number, videoId: string): Promise<any[]>;
    getOwnIssues(): Promise<types.IIssue[]>;
    sendFeedback(title: string, message: string, fileBundle: string, anonymous: boolean, groupingKey?: string, id?: string): Promise<types.IFeedbackResponse>;
    private defaultCreateQuery;
    private checkFileSize;
    private request;
    private makeQueryImpl;
    private makeParameters;
    private makeFilter;
    private makeQuery;
    private makeMutation;
    private genError;
    private requestGraph;
    private requestGraphWithErrors;
    private convertErrDetail;
    private mutateGraph;
    private set oAuthCredentials(value);
    handleJwtRefresh(): Promise<types.IOAuthCredentials>;
    private filter;
    private args;
}
export default Nexus;
